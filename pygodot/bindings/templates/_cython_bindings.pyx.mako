# Generated by PyGodot binding generator
<%!
    from pygodot.bindings._generator import python_module_name, CORE_TYPES, remove_nested_type_prefix, clean_signature, clean_return_type
%>
from godot_headers.gdnative_api cimport godot_method_bind, godot_gdnative_ext_nativescript_1_1_api_struct
from pygodot.globals cimport gdapi, nativescript_1_1_api, _cython_language_index

from cpython.object cimport PyObject

from pygodot._core cimport _Wrapped

# Avoid c-importing "_Wrapped" and "Object"
from pygodot.bindings.cpp.core_types cimport real_t, ${', '.join(CORE_TYPES)}

from pygodot.bindings.cython.__icalls cimport *


cdef __method_bindings __mb
% for class_name, class_def, includes, forwards, methods in classes:


% if class_def['singleton']:
cdef object __${class_name}___singleton = None

% endif
cdef class ${class_name}(${class_def['base_class'] or '_Wrapped'}):
% for method_name, return_type, pxd_signature, signature, args in methods:
    cdef ${clean_return_type(return_type, forwards, includes, class_name, class_def['base_class'])}${method_name}(
        self${', ' if signature else ''}${clean_signature(signature, forwards, includes, class_name, class_def['base_class'])}):
    % if (class_name + '#' + method_name) in icall_names and 'Object' not in icall_names[class_name + '#' + method_name]:
        ${('return <%s>' % clean_return_type(return_type, forwards, includes, class_name, class_def['base_class']).rstrip()) if return_type != 'void ' else ''}${icall_names[class_name + '#' + method_name]}(__mb.__${class_name}__mb_${method_name}, (<_Wrapped><PyObject *>self)._owner${', %s' % ', '.join(a[1] for a in args) if args else ''})
    % else:
        % if (class_name + '#' + method_name) in icall_names:
        # TODO: Convert Python arguments to GDNative objects and do an icall
        % endif
        raise NotImplementedError("${class_name}.${method_name}() is not implemented yet")
    % endif

% endfor
% if class_def['singleton']:
    def __cinit__(self):
        self._owner = gdapi.godot_global_get_singleton(<char *>"${class_name}")
        print("Init ${class_name} singleton 0x%x" % <size_t>self._owner)

    @staticmethod
    cdef object get_singleton():
        global __${class_name}___singleton

        if __${class_name}___singleton is None:
            __${class_name}___singleton = ${class_name}()

        return __${class_name}___singleton

% elif not methods:
        pass

% endif
cdef public const void *_Cython${class_name}Ptr = <const void *>${class_name}
% endfor


cdef public void __init_cython_method_bindings():
% for class_name, class_def, includes, forwards, methods in classes:
    % for method_name, return_type, pxd_signature, signature, args in methods:
    __mb.__${class_name}__mb_${method_name} = gdapi.godot_method_bind_get_method("${class_def['name']}", "${method_name}")
    % endfor
% endfor


cdef public void __register_cython_types():
    cdef int i = _cython_language_index
    cdef const godot_gdnative_ext_nativescript_1_1_api_struct *ns11api = nativescript_1_1_api

    print("Cython language index", i)

% for class_name, class_def, includes, forwards, methods in classes:
    ns11api.godot_nativescript_set_global_type_tag(i, "${class_def['name']}", _Cython${class_name}Ptr)
% endfor
