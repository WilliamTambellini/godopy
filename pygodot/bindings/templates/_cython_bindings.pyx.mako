# Generated by PyGodot binding generator
<%!
    from pygodot.bindings._generator import python_module_name, is_class_type, CORE_TYPES, \
        remove_nested_type_prefix, clean_signature, cython_nonempty_comparison

    def make_arg(arg):
        if is_class_type(arg[2]['type']):
            return '%s._owner' % arg[1]
        return arg[1]
%>
from godot_headers.gdnative_api cimport godot_object, godot_variant, godot_method_bind, godot_gdnative_ext_nativescript_1_1_api_struct
from pygodot.globals cimport gdapi, nativescript_1_1_api, _cython_language_index

from cpython.object cimport PyObject

from pygodot._core cimport _Wrapped

# Avoid c-importing "_Wrapped" and "Object"
from pygodot.bindings.cpp.core_types cimport real_t, ${', '.join(CORE_TYPES)}
from pygodot.bindings.cython.__icalls cimport *


cdef __method_bindings __mb
% for class_name, class_def, includes, forwards, methods in classes:


% if class_def['singleton']:
cdef object __${class_name}___singleton = None

% endif
cdef class ${class_name}(${class_def['base_class'] or '_Wrapped'}):
% for method_name, method, return_type, pxd_signature, signature, args, return_stmt in methods:
    cdef ${return_type}${method_name}(self${', ' if signature else ''}${clean_signature(signature, class_name)}):
    % if method['has_varargs']:
        % if args:
        cdef Variant __given_args[${len(args)}]
        % endif
        % for i, (arg_type, arg_name, arg) in enumerate(args):
        ## XXX: C++ bindings do this: gdapi.godot_variant_new_nil(<godot_variant *>&__given_args[${i}]); __given_args[${i}] = ${arg_name};
        if ${arg_name} ${cython_nonempty_comparison(arg['type'])}:
            __given_args[${i}] = <Variant>${arg_name}
        else:
            gdapi.godot_variant_new_nil(<godot_variant *>&__given_args[${i}])
        % endfor

        cdef godot_variant **__args = <godot_variant **>gdapi.godot_alloc(sizeof(godot_variant *) * (len(__var_args) + ${len(args)}))
        % for i, (arg_type, arg_name, arg) in enumerate(args):
        __args[${i}] = <godot_variant *>&__given_args[${i}]
        % endfor

        cdef int i
        cdef Variant __arg
        for i in range(len(__var_args)):
            ## FIXME
            __arg = <Variant>__var_args[i]
            __args[i + ${len(args)}] = <godot_variant *>&__arg

        cdef godot_variant __cresult = gdapi.godot_method_bind_call(__mb.__${class_name}__mb_${method_name}, self._owner, <const godot_variant **>__args, (len(__var_args) + ${len(args)}), NULL)
        ## FIXME
        cdef Variant *__result_ptr = <Variant *>&__cresult
        cdef Variant __result = __result_ptr[0]

        % for i, (arg_type, arg_name, arg) in enumerate(args):
        gdapi.godot_variant_destroy(<godot_variant *>&__given_args[${i}])
        % endfor
        ## XXX: Godot should free __args in godot_method_bind_call

        % if is_class_type(method['return_type']):
        cdef godot_object *ret = <godot_object *>__result
        if not ret:
            raise RuntimeError('${class_name}.${method_name}() call failed')
        return <${class_name}>nativescript_1_1_api.godot_nativescript_get_instance_binding_data(_cython_language_index, ret)

        % elif method['return_type'] != 'void':
        ${return_stmt}__result
        % endif
    % else:
        ${return_stmt}${icall_names[class_name + '#' + method_name]}(__mb.__${class_name}__mb_${method_name}, self._owner${', %s' % ', '.join(make_arg(a) for a in args) if args else ''})
    % endif

% endfor
% if class_def['singleton']:
    def __cinit__(self):
        self._owner = gdapi.godot_global_get_singleton(<char *>"${class_name}")
        print("Init ${class_name} singleton 0x%x" % <size_t>self._owner)

    @staticmethod
    cdef object get_singleton():
        global __${class_name}___singleton

        if __${class_name}___singleton is None:
            __${class_name}___singleton = ${class_name}()

        return __${class_name}___singleton

% elif not methods:
        pass

% endif
% endfor


cdef public void __init_cython_method_bindings():
% for class_name, class_def, includes, forwards, methods in classes:
    % for method_name, method, return_type, pxd_signature, signature, args, return_stmt in methods:
    __mb.__${class_name}__mb_${method_name} = gdapi.godot_method_bind_get_method("${class_def['name']}", "${method_name}")
    % endfor
% endfor


cdef public void __register_cython_types():
    cdef int i = _cython_language_index
    cdef const godot_gdnative_ext_nativescript_1_1_api_struct *ns11api = nativescript_1_1_api

    print("Cython language index", i)

% for class_name, class_def, includes, forwards, methods in classes:
    ns11api.godot_nativescript_set_global_type_tag(i, "${class_def['name']}", <const void *>${class_name})
% endfor
