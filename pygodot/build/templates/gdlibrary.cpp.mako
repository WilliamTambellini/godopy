/* Generated by PyGodot ${__version__} */
#include "GodotGlobal.hpp"
#include "Defs.hpp"
#include "PythonGlobal.hpp"

#include "godot/nativescript.h"
#include "godot/gdnative.h"

PyMODINIT_FUNC PyInit_core_types();
PyMODINIT_FUNC PyInit__cython_bindings();
PyMODINIT_FUNC PyInit__python_bindings();
PyMODINIT_FUNC PyInit_utils();

% for varname, _, _ in pyx_sources:
PyMODINIT_FUNC PyInit_${varname}(void);
% endfor

extern "C" PyObject *_pygodot_nativescript_init();
% if singleton:
extern "C" PyObject *_pygodot_gdnative_singleton();
% endif
% if gdnative_init:
extern "C" PyObject *_pygodot_gdnative_init(godot_gdnative_init_options *)
% endif

static bool _pygodot_is_initialized = false;

static PyModuleDef ${library_name}module = {
  PyModuleDef_HEAD_INIT, "${library_name}",
  "${repr(library)} GDNative extension",
  -1
};

PyMODINIT_FUNC PyInit_${library_name}(void) { return PyModule_Create(&${library_name}module); }

#ifndef PYGODOT_EXPORT
#ifndef _WIN32
inline FILE* _popen(const char* command, const char* type) {
   return popen(command, type);
}
inline void _pclose(FILE* file) { 
   pclose(file); 
}
#endif
#include <iostream>
#include <stdexcept>
#include <stdio.h>
#include <string>
#include <algorithm>
const std::string shelloutput(const char* cmd) {
  char buffer[128];
  std::string result = "";
  FILE* pipe = _popen(cmd, "r");
  if (!pipe) throw std::runtime_error("popen() failed!");
  try {
    while (fgets(buffer, sizeof buffer, pipe) != NULL) {
      result += buffer;
    }
  } catch (...) {
    _pclose(pipe);
    throw;
  }
  _pclose(pipe);

  result.erase(std::find_if(result.rbegin(), result.rend(), [](int ch) {
    return !std::isspace(ch);
  }).base(), result.end());

  return result;
}
#endif

static void _ensure_pygodot_is_initialized() {
  if (_pygodot_is_initialized) return;

#ifndef PYGODOT_EXPORT
#ifndef _WIN32
  static bool use_pipenv = (system("python -c 'import pygodot;_=print' &> /dev/null") != 0);

  if (system(use_pipenv ? "pipenv run python -c 'import pygodot;_=print' &> /dev/null" :
                                     "python -c 'import pygodot;_=print' &> /dev/null") != 0) {
    throw std::runtime_error("unusable Python environment");
  }

  // Copy the correct Python paths for development
  const std::string dev_python_path = use_pipenv ?
    shelloutput("pipenv run python -c \"print(':'.join(__import__('sys').path))\"") :
    shelloutput("python -c \"print(':'.join(__import__('sys').path))\"") ;
  const wchar_t *w_dev_python_path = Py_DecodeLocale(dev_python_path.c_str(), NULL);
  Py_SetPath(w_dev_python_path);
  PyMem_RawFree((void *)w_dev_python_path);
#else
  Py_SetPath(L"c:\\python37\\Lib;c:\\python37\\DLLs;c:\\demos\\cython-example\\pygodot;c:\\demos\\cython-example");
#endif
#endif

  PyImport_AppendInittab("${library_name}", PyInit_${library_name});
  PyImport_AppendInittab("core_types", PyInit_core_types);
  PyImport_AppendInittab("_cython_bindings", PyInit__cython_bindings);
  PyImport_AppendInittab("_python_bindings", PyInit__python_bindings);
  PyImport_AppendInittab("utils", PyInit_utils);
  PyImport_AppendInittab("nativescript", PyInit_nativescript);
  PyImport_AppendInittab("gdnative", PyInit_gdnative);

% for varname, _, _ in reversed(pyx_sources):
  PyImport_AppendInittab("${varname}", PyInit_${varname});
% endfor

  pygodot::PyGodot::python_init();

  // Importing of Cython modules is required to correctly initialize them
  PyObject *mod = NULL;
  // TODO: add Godot error handling
  mod = PyImport_ImportModule("core_types"); ERR_FAIL_PYTHON_NULL(mod);; Py_DECREF(mod);
  mod = PyImport_ImportModule("_cython_bindings"); ERR_FAIL_PYTHON_NULL(mod); Py_DECREF(mod);
  mod = PyImport_ImportModule("_python_bindings"); ERR_FAIL_PYTHON_NULL(mod); Py_DECREF(mod);
  mod = PyImport_ImportModule("utils"); ERR_FAIL_PYTHON_NULL(mod); Py_DECREF(mod);
  mod = PyImport_ImportModule("nativescript"); ERR_FAIL_PYTHON_NULL(mod); Py_DECREF(mod);
  mod = PyImport_ImportModule("gdnative"); ERR_FAIL_PYTHON_NULL(mod); Py_DECREF(mod);

% for varname, _, _ in reversed(pyx_sources):
  mod = PyImport_ImportModule("${varname}"); ERR_FAIL_PYTHON_NULL(mod); Py_DECREF(mod);
% endfor

  _pygodot_is_initialized = true;
}

extern "C" void GDN_EXPORT pygodot_gdnative_init(godot_gdnative_init_options *o) {
  godot::Godot::gdnative_init(o);
  pygodot::PyGodot::set_pythonpath(o);

% if gdnative_init:
  PyObject *result = _pygodot_gdnative_init(o); ERR_FAIL_PYTHON_NULL(result);
% endif
}

extern "C" void GDN_EXPORT pygodot_gdnative_terminate(godot_gdnative_terminate_options *o) {
  godot::Godot::gdnative_terminate(o);
  pygodot::PyGodot::python_terminate();
}

extern "C" void GDN_EXPORT pygodot_nativescript_init(void *handle) {
  godot::Godot::nativescript_init(handle); // C++ bindings
  _ensure_pygodot_is_initialized();
  pygodot::PyGodot::nativescript_init(handle);

  PyObject *result = _pygodot_nativescript_init(); ERR_FAIL_PYTHON_NULL(result);
}

extern "C" void GDN_EXPORT pygodot_gdnative_singleton() {
  _ensure_pygodot_is_initialized();
% if singleton:
  PyObject *result = _pygodot_gdnative_singleton(); ERR_FAIL_PYTHON_NULL(result);
% endif
}

extern "C" void GDN_EXPORT pygodot_nativescript_terminate(void *handle) {
  pygodot::PyGodot::nativescript_terminate(handle);
  godot::Godot::nativescript_terminate(handle); // C++ bindings
}
